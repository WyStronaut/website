<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>07_countability (MathJax Version)</title>
  <style>
    /* Styles will be inserted here */
  </style>
  <script>
  /*
    Starter MathJax macro config for WyStronaut/website
    - Mirrors common custom commands from zeramorphic/cambridge-maths-notes/util.sty
    - Safe, incremental starter: focuses on macros likely to appear in converted HTML math
    - Add more as needed when new unresolved macros show up

    Place this BEFORE the MathJax script tag (or inject via pandoc --include-in-header).
  */

  window.MathJax = {
    tex: {
      // Usually not needed for standard combined MathJax bundles, but harmless if present.
      // configmacros is the extension that enables tex.macros / tex.environments config.
      packages: {'[+]': ['configmacros']},

      macros: {
        /* ---------- Requested extra macro ---------- */
        // LaTeX source equivalent: \newcommand{\abs}[1]{\lvert #1 \rvert}
        abs: ["\\lvert #1 \\rvert", 1],

        /* ---------- Core macros already seen in generated IA/NS MathJax HTML ---------- */
        st: "\\text{ s.t. }",
        genset: ["\\left\\langle{} #1 \\right\\rangle", 1],
        HCF: "\\operatorname{HCF}",
        LCM: "\\operatorname{LCM}",
        Im: "\\operatorname{Im}",   // util.sty renews \Im
        Re: "\\operatorname{Re}",   // util.sty renews \Re

        /* ---------- util.sty custom notation macros (simple wrappers) ---------- */
        ddempty: "\\mathrm{d}",
        dn: ["\\mathrm{d}^{#1}#2", 2],
        contradiction: "\\#",
        ngenset: ["\\left\\langle\\!\\left\\langle{} #1 \\right\\rangle\\!\\right\\rangle", 1],
        midd: "\\,\\middle|\\,",
        nhat: "\\hat{\\mathbf{n}}",
        rdot: "\\dot{\\mathbf{r}}",
        rddot: "\\ddot{\\mathbf{r}}",
        transpose: "\\intercal",
        acts: "\\curvearrowright",
        adjugate: ["\\widetilde{#1}", 1],
        stcomp: ["{#1}^{c}", 1],
        convdist: "\\xrightarrow{d}",
        convprob: "\\xrightarrow{\\mathbb{P}}",
        wildcard: "{}\\cdot{}",
        sstar: "{\\star\\star}",
        Mob: "\\text{M\\\"ob}",
        Chat: "\\widehat{\\mathbb C}",
        cop: "\\mathrm{op}",
        hhat: ["\\hat{\\hat{#1}}", 1],

        /* ---------- Common probability / expectation wrappers ---------- */
        prob: ["\\mathbb{P}\\left(#1\\right)", 1],
        psub: ["\\mathbb{P}_{#1}\\left(#2\\right)", 2],
        psubx: ["\\mathbb{P}_{x}\\left(#1\\right)", 1],
        expect: ["\\mathbb{E}\\left[#1\\right]", 1],
        esub: ["\\mathbb{E}_{#1}\\left[#2\\right]", 2],
        esubx: ["\\mathbb{E}_{x}\\left[#1\\right]", 1],
        Var: ["\\Varop\\left(#1\\right)", 1],
        Varsub: ["\\Varop_{#1}\\left(#2\\right)", 2],
        Cov: ["\\Covop\\left(#1\\right)", 1],
        Corr: ["\\Corrop\\left(#1\\right)", 1],
        Markov: ["\\Markovop\\left(#1\\right)", 1],

        /* ---------- Pairing / inner-product style wrappers ---------- */
        inner: ["\\left\\langle #1\\right\\rangle", 1],

        /* ---------- Operator declarations from util.sty ---------- */
        vecspan: "\\operatorname{span}",
        ord: "\\operatorname{ord}",
        Sym: "\\operatorname{Sym}",
        nullity: "\\operatorname{null}",
        Orb: "\\operatorname{Orb}",
        Stab: "\\operatorname{Stab}",
        ccl: "\\operatorname{ccl}",
        Varop: "\\operatorname{Var}",
        Covop: "\\operatorname{Cov}",
        Corrop: "\\operatorname{Corr}",
        Markovop: "\\operatorname{Markov}",
        adj: "\\operatorname{adj}",
        sgn: "\\operatorname{sgn}",
        diam: "\\operatorname{diam}",
        id: "\\operatorname{id}",
        Log: "\\operatorname{Log}",
        Iff: "\\operatorname{I}",
        IIff: "\\operatorname{I\\!I}",
        artanh: "\\operatorname{artanh}",
        Aut: "\\operatorname{Aut}",
        Hom: "\\operatorname{Hom}",
        graft: "\\operatorname{graft}",
        Gal: "\\operatorname{Gal}",
        Instr: "\\operatorname{Instr}",
        // esssup is declared with * in LaTeX (limits-style); this approximation is usually fine:
        esssup: "\\operatorname*{ess\\ sup}",
        dom: "\\operatorname{dom}",
        fchar: "\\operatorname{char}",
        code: "\\operatorname{code}",
        im: "\\operatorname{im}",
        coker: "\\operatorname{coker}",
        coim: "\\operatorname{coim}",
        End: "\\operatorname{End}",
        ob: "\\operatorname{ob}",
        mor: "\\operatorname{mor}",
        cod: "\\operatorname{cod}",
        Spec: "\\operatorname{Spec}",
        mSpec: "\\operatorname{mSpec}",
        Proj: "\\operatorname{Proj}",
        res: "\\operatorname{res}",
        Con: "\\operatorname{Con}",
        cf: "\\operatorname{cf}",
        ran: "\\operatorname{ran}",
        Fn: "\\operatorname{Fn}"

        /*
          Intentionally omitted (for starter simplicity or because they depend on other custom macros/packages):
          - vu, nhat(via \vu), rdot/rddot exact forms using \vb from physics package (we used \\mathbf fallback)
          - mathhuge, symmdiff, bound (can be added later if they appear unresolved)
          - divergence/\div redefinitions via \DeclareDocumentCommand (complex parser behavior)
          - \ceil, \floor, \Brackets from \DeclarePairedDelimiter (better to define individually if encountered)
          - TikZ / theorem / text formatting commands (not MathJax macros)
        */
      }
    }
  };
  </script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>

<a href="#main">Skip to main content</a>

<header>
  <h1>07_countability (MathJax Version)</h1>
</header>

<nav aria-label="Page Navigation">
  <ul>
    <li><a href="../">Back to Generated Index</a></li>
            <li><a href="../mathml/07_countability-mathml.html">Switch to MathML Version</a></li>
      </ul>
</nav>

<main id="main">
<h2 id="basic-properties">Basic properties</h2>
<p>We have a notion of ‘size’ for finite sets. Is there such an
analogous notion for infinite sets? We will say that a set <span
class="math inline">\(X\)</span> is countable if <span
class="math inline">\(X\)</span> is finite, or it bijects with <span
class="math inline">\(\mathbb N\)</span>. Equivalently, we can list out
the elements of the set, and each element will appear in the list. Here
are some examples.</p>
<ol>
<li><p>Clearly any finite set is countable.</p></li>
<li><p><span class="math inline">\(\mathbb N\)</span> is
countable.</p></li>
<li><p><span class="math inline">\(\mathbb Z\)</span> is countable, let
us construct the list of numbers <span class="math display">\[0, 1, -1,
2, -2, 3, -3, 4, -4, \dots\]</span></p></li>
</ol>
<p>It makes sense now to consider two sets to have the same size if they
biject with each other.</p>
<h3>Proposition</h3>
<p>A set <span class="math inline">\(X\)</span> is countable if and only
if it injects into <span class="math inline">\(\mathbb N\)</span>.</p>
<h3>Proof</h3>
<p>The forward implication is trivial: if <span
class="math inline">\(X\)</span> is finite, then there must be an
injection in to <span class="math inline">\(\mathbb N\)</span>, and if
it bijects with <span class="math inline">\(\mathbb N\)</span> then that
bijection is a valid injection. This encompasses both cases of countable
sets.</p>
<p>Now let us consider the reverse implication. We may assume <span
class="math inline">\(X\)</span> is infinite, since if <span
class="math inline">\(X\)</span> is finite then by definition <span
class="math inline">\(X\)</span> is countable. We know that <span
class="math inline">\(X\)</span> injects onto <span
class="math inline">\(\mathbb N\)</span> under some injective function
<span class="math inline">\(f\)</span>, so <span
class="math inline">\(X\)</span> bijects with <span
class="math inline">\(\Im f\)</span>. So it is enough to show that the
image <span class="math inline">\(\Im f\)</span> is countable. We will
now set <span class="math inline">\(a_1\)</span> to be the least element
of <span class="math inline">\(\Im f\)</span>, and <span
class="math inline">\(a_2\)</span> to be the least element not equal to
<span class="math inline">\(a_1\)</span>, and so on. In general, <span
class="math inline">\(a_n = \min (\Im f \setminus \{ a_i : 0 \leq i &lt;
n \})\)</span>. Then <span class="math inline">\(\Im f\)</span> is the
set <span class="math inline">\(\{ a_1, a_2, \dots \}\)</span>. There
are no extra elements that we have not covered, since each <span
class="math inline">\(a \in X\)</span> is <span
class="math inline">\(a_n\)</span> for some <span
class="math inline">\(n\)</span>, because <span
class="math inline">\(a=a_n, n \leq a\)</span>. So we have listed
elements of <span class="math inline">\(\Im f\)</span>, so <span
class="math inline">\(\Im f\)</span> is countable, so <span
class="math inline">\(X\)</span> is countable. ◻</p>
<p>Thus, we can view countability as being ‘at most as large as <span
class="math inline">\(\mathbb N\)</span>’. For instance, any subset of a
countable set is also countable.</p>
<h3>Remark</h3>
<p>In <span class="math inline">\(\mathbb R\)</span>, let <span
class="math display">\[X = \left\{ \frac{1}{2}, \frac{2}{3},
\frac{3}{4}, \dots \right\} \cup \{ 1 \}\]</span> Then <span
class="math inline">\(X\)</span> is countable, as we can list it as
<span class="math display">\[1, \frac{1}{2}, \frac{2}{3}, \frac{3}{4},
\dots\]</span> But if we counted from ‘least element’ to ‘most element’,
we would never reach the element 1 in countable time. Note further that
if we find it difficult to construct a list for a set, it does not mean
it is uncountable, it could just mean that we haven’t found the right
list yet.</p>
<h2 id="products-of-countable-sets">Products of countable sets</h2>
<h3>Theorem</h3>
<p><span class="math inline">\(\mathbb N \times \mathbb N\)</span> is
countable.</p>
<h3>Proof</h3>
<p><em>Proof 1.</em> We will define <span class="math inline">\(a_1 =
(1, 1)\)</span>, and inductively define <span class="math display">\[a_n
= \begin{cases}
            (p-1, q+1) &amp; \text{if } p &gt; 1 \\
            (q+1, 1)   &amp; \text{if } p = 1
        \end{cases}\]</span> where <span class="math inline">\(a_{n-1} =
(p, q)\)</span>. Therefore, we are essentially moving across
antidiagonals of the plane. This does hit every point <span
class="math inline">\((x, y) \in \mathbb N \times \mathbb N\)</span>,
for example by induction on <span class="math inline">\(x+y\)</span>, so
we have listed all elements of <span class="math inline">\(\mathbb N
\times \mathbb N\)</span>. ◻</p>
<h3>Proof</h3>
<p><em>Proof 2.</em> If we can define an injective function <span
class="math inline">\(\mathbb N \times \mathbb N \to \mathbb N\)</span>,
then it is countable. For example, let <span class="math inline">\(f =
2^x 3^y\)</span>. <span class="math inline">\(f\)</span> is injective,
so <span class="math inline">\(\mathbb N \times \mathbb N\)</span> is
countable. ◻</p>
<h2 id="countable-unions-of-countable-sets">Countable unions of
countable sets</h2>
<p>Proof 2 is also a way to show the following theorem:</p>
<h3>Theorem</h3>
<p>Let <span class="math inline">\(A_1, A_2, A_3, \dots\)</span> be
countable sets. Then <span class="math inline">\(A_1 \cup A_2 \cup A_3
\cup \dots\)</span> is countable. Less formally, ‘a countable union of
countable sets is countable’.</p>
<h3>Proof</h3>
<p>For each <span class="math inline">\(i\)</span>, <span
class="math inline">\(A_i\)</span> is countable, so we can list <span
class="math inline">\(A_i\)</span> as <span
class="math inline">\(a_{i1}, a_{i2}, a_{i3}, \dots\)</span> which may
or may not terminate. We can then define <span
class="math display">\[f\colon \bigcup_{n \in \mathbb N}A_n \to \mathbb
N;\quad f(x) = 2^i 3^j\]</span> where <span class="math inline">\(x =
a_{ij}\)</span>. If <span class="math inline">\(x\)</span> is in more
than one set, just take the least <span class="math inline">\(i\)</span>
that is valid. Then <span class="math inline">\(f\)</span> is an
injection so the union is countable. ◻</p>
<p>Here are some examples of using this theorem by partitioning sets as
a countable union of countable subsets.</p>
<ol>
<li><p><span class="math inline">\(\mathbb Q\)</span> is countable,
since it is a countable union of countable sets: <span
class="math display">\[\mathbb Q = \mathbb Z \cup \frac{1}{2}\mathbb Z
\cup \frac{1}{3}\mathbb Z \cup \dots\]</span> Each <span
class="math inline">\(\frac{1}{n}\mathbb Z\)</span> is countable, since
they biject with <span class="math inline">\(\mathbb Z\)</span> which is
a countable set. It doesn’t matter if we’ve counted an element in <span
class="math inline">\(\mathbb Q\)</span> twice; the above theorem works
even with intersecting sets.</p></li>
<li><p>The set <span class="math inline">\(\mathbb A\)</span> of all
algebraic numbers is countable. It is enough to show that the set of
integer polynomials is countable, since each polynomial has a finite
amount of roots and then <span class="math inline">\(\mathbb A\)</span>
is a countable union of finite sets. Now, to show that the set of
integer polynomials is countable, it is enough to show that for each
degree <span class="math inline">\(d\)</span> it is countable, since it
is a countable union of all polynomials of degree <span
class="math inline">\(d\)</span> (again using the above theorem). To
specify a polynomial of degree <span class="math inline">\(d\)</span>
you must name its coefficients, so this set injects into <span
class="math inline">\(\mathbb Z^{d+1}\)</span>, so we must just show
that <span class="math inline">\(\mathbb Z^{d+1}\)</span> is countable
(not a bijection since the first term of the polynomial must be
nonzero). We know that <span class="math inline">\(\mathbb Z^n\)</span>
is countable because we can inductively show that <span
class="math inline">\(\mathbb Z^2, \mathbb Z^3, \mathbb Z^4,
\dots\)</span> are countable inductively.</p></li>
</ol>
<h2 id="uncountable-sets">Uncountable sets</h2>
<h3>Definition</h3>
<p>A set is uncountable if there is no way to count the set.</p>
<h3>Theorem</h3>
<p><span class="math inline">\(\mathbb R\)</span> is uncountable.</p>
<h3>Proof</h3>
<p><em>Proof (Cantor’s Diagonal Argument).</em> We will show that <span
class="math inline">\((0, 1)\)</span> is uncountable, then clearly <span
class="math inline">\(\mathbb R\)</span> is uncountable. Suppose <span
class="math inline">\((0, 1)\)</span> is countable. Then given a
sequence <span class="math inline">\(r_1, r_2, \dots\)</span> in <span
class="math inline">\((0, 1)\)</span>, we just need to find some number
<span class="math inline">\(s \in (0, 1)\)</span> not contained within
this sequence. For each <span class="math inline">\(r_n\)</span>, we
have a decimal expansion <span class="math inline">\(r_n =
0.r_{n1}r_{n2}r_{n3}\dots\)</span>. Let us now write all of these
numbers in a matrix-style form: <span
class="math display">\[\begin{align*}
        r_1 &amp; = 0.r_{11}r_{12}r_{13}\dots \\
        r_2 &amp; = 0.r_{21}r_{22}r_{23}\dots \\
        r_3 &amp; = 0.r_{31}r_{32}r_{33}\dots \\
        \vdots
\end{align*}\]</span> We just need to construct some number <span
class="math inline">\(s\)</span> that is not in this list. So, let us
simply make sure that for any given <span
class="math inline">\(r\)</span> value, there is at least one digit that
does not match. The easiest way to construct such a number is <span
class="math display">\[s = 0.s_1 s_2 s_3 \dots\]</span> where <span
class="math inline">\(s_1 \neq r_{11}\)</span>, <span
class="math inline">\(s_2 \neq r_{22}\)</span>, <span
class="math inline">\(s_3 \neq r_{33}\)</span> and so on. We can pick
any numbers we like according to these constraints, but we should avoid
picking digits 0 and 9 since <span class="math inline">\(0.1000\dots =
0.0999\dots\)</span> for example, which could cause unnecessary
ambiguity. Then <span class="math inline">\(s \neq r_1, s \neq r_2,
\dots\)</span> since there is at least one mismatched digit in the
expansion for each <span class="math inline">\(r_i\)</span>; they differ
in decimal digit <span class="math inline">\(i\)</span>. So <span
class="math inline">\(\mathbb R\)</span> is uncountable. ◻</p>
<p>This is another proof that transcendental numbers exist. <span
class="math inline">\(\mathbb R\)</span> is uncountable and <span
class="math inline">\(\mathbb A\)</span> is countable, so there exists a
transcendental number. Indeed, ‘most’ numbers are transcendental,
i.e. <span class="math inline">\(\mathbb R \setminus \mathbb A\)</span>
is uncountable (because if <span class="math inline">\(\mathbb R
\setminus \mathbb A\)</span> were countable, then <span
class="math inline">\(\mathbb R\)</span> would be <span
class="math inline">\((\mathbb R \setminus \mathbb A) \cup \mathbb
A\)</span> which is a finite union of countable sets ).</p>
<h3>Theorem</h3>
<p>The power set <span class="math inline">\(\mathcal P(\mathbb
N)\)</span> is uncountable.</p>
<h3>Proof</h3>
<p>Suppose the subsets of <span class="math inline">\(\mathbb N\)</span>
are listed as <span class="math inline">\(S_1, S_2, S_3, \dots\)</span>
then we want to construct another set <span
class="math inline">\(S\)</span> that is not equal to any of the other
sets <span class="math inline">\(S_i\)</span>. So for each set <span
class="math inline">\(S_i\)</span>, we must ensure that <span
class="math inline">\(S\)</span> and <span
class="math inline">\(S_i\)</span> differ for at least one value. An
easy way to do this is to include the number <span
class="math inline">\(i\)</span> in the subset if <span
class="math inline">\(S_i\)</span> does not contain the number, and to
exclude <span class="math inline">\(i\)</span> if <span
class="math inline">\(i \in S_i\)</span>. Then <span
class="math inline">\(S\)</span> differs from <span
class="math inline">\(S_i\)</span> at position <span
class="math inline">\(i\)</span>. This is the same logic as the diagonal
argument above. We have: <span class="math display">\[S = \{ n \in
\mathbb N : n \notin S_n \}\]</span> So <span
class="math inline">\(S\)</span> is not on the list <span
class="math inline">\(S_1, S_2, S_3, \dots\)</span> no matter what way
we choose to list the elements, so <span class="math inline">\(\mathcal
P(\mathbb N)\)</span> is uncountable. ◻</p>
<h3>Remark</h3>
<p>Alternatively, we could just inject <span class="math inline">\((0,
1)\)</span> into <span class="math inline">\(\mathcal P(\mathbb
N)\)</span>. For example, consider <span class="math inline">\(x \in (0,
1)\)</span> represented as <span
class="math inline">\(0.x_1x_2x_3x_4\dots\)</span> in binary where the
<span class="math inline">\(x_1, x_2, \dots\)</span> are zero or one
(not ending with an infinite amount of 1s). We can convert this <span
class="math inline">\(x\)</span> into a subset of <span
class="math inline">\(\mathbb N\)</span> by considering the set <span
class="math inline">\(\{ n \in \mathbb N : x_n = 1 \}\)</span>. Then the
uncountability follows.</p>
<p>In fact, our proof of this theorem shows the following.</p>
<h3>Theorem</h3>
<p>For any set <span class="math inline">\(X\)</span>, there is no
bijection from <span class="math inline">\(X\)</span> to the power set
<span class="math inline">\(\mathcal P(X)\)</span>.</p>
<p>For example, <span class="math inline">\(\mathbb R\)</span> does not
biject with <span class="math inline">\(\mathcal P(\mathbb R)\)</span>.
The proof in fact will show that there is no surjection from <span
class="math inline">\(X\)</span> to its power set; i.e. the power set is
‘larger’ than <span class="math inline">\(X\)</span>.</p>
<h3>Proof</h3>
<p>Given any function <span class="math inline">\(f\colon X \to \mathcal
P(X)\)</span>, we will show <span class="math inline">\(f\)</span> is
not surjective. Let <span class="math inline">\(S = \{ x \in X: x \notin
f(x) \}\)</span>. Then <span class="math inline">\(S\)</span> does not
belong to the image of <span class="math inline">\(f\)</span> because
they differ at element <span class="math inline">\(x\)</span>; for all
<span class="math inline">\(x\)</span> we have <span
class="math inline">\(S \neq f(x)\)</span>. ◻</p>
<h3>Remark</h3>
<p>Note that:</p>
<ol>
<li><p>This is similar in some sense to Russell’s paradox.</p></li>
<li><p>This theorem gives another proof that there is no universal set
<span class="math inline">\(\mathscr E\)</span>, since its power set
<span class="math inline">\(\mathcal P(\mathscr E) \subseteq \mathscr
E\)</span>. But of course, there is always a surjection from a set to a
subset. This is a contradiction.</p></li>
</ol>
<h3>Example</h3>
<p>Let <span class="math inline">\(A_i, i \in I\)</span> be a family of
open, pairwise disjoint intervals. Must this family be countable? Note
that it is not as simple as just listing from left to right, for example
consider <span class="math display">\[\left(\frac{1}{2}, 1\right),
\left(\frac{1}{3}, \frac{1}{2}\right), \left(\frac{1}{4},
\frac{1}{3}\right), \dots, (-1, 0)\]</span> Then the leftmost interval
is <span class="math inline">\((-1, 0)\)</span>, but there is no ‘next
interval’ just after it. Also consider <span
class="math display">\[\left( 0, \frac{1}{2} \right), \left(
\frac{1}{2}, \frac{2}{3} \right), \left( \frac{2}{3}, \frac{3}{4}
\right), \dots, (1, 2)\]</span> Then we can list the first infinitely
many intervals, but we will never reach <span class="math inline">\((1,
2)\)</span>. The answer turns out to be true; the family is countable.
Here are two important proofs.</p>
<h3>Proof</h3>
<p><em>Proof 1.</em> Each interval <span
class="math inline">\(A_i\)</span> contains a rational number <span
class="math inline">\(a_i\)</span>. The rationals <span
class="math inline">\(\mathbb Q\)</span> are countable. So let us just
list the <span class="math inline">\(a_i\)</span>. The family is
therefore countable. ◻</p>
<h3>Proof</h3>
<p><em>Proof 2.</em> <span class="math inline">\(\{ i \in I: A_i \text{
has length } \leq 1\}\)</span> is certainly countable, since it injects
into <span class="math inline">\(\mathbb Z\)</span> (here, as all <span
class="math inline">\(A_i\)</span> contain some integer). Further, <span
class="math inline">\(\left\{ i \in I: A_i \text{ has length } \leq
\frac{1}{2} \right\}\)</span> is countable for the same reason.
Essentially, for all <span class="math inline">\(n\)</span>, <span
class="math inline">\(\left\{ i \in I: A_i \text{ has length } \leq
\frac{1}{n} \right\}\)</span> is countable. We have written all the
intervals as a countable union (over <span
class="math inline">\(n\)</span>) of countable sets. ◻</p>
<p>To summarise, if we want to show a set <span
class="math inline">\(X\)</span> is uncountable:</p>
<ol>
<li><p>Run a diagonal argument; or</p></li>
<li><p>Inject an uncountable set into <span
class="math inline">\(X\)</span></p></li>
</ol>
<p>To show a set <span class="math inline">\(X\)</span> is
countable:</p>
<ol>
<li><p>List all the elements (usually fiddly); or</p></li>
<li><p>Inject <span class="math inline">\(X\)</span> into <span
class="math inline">\(\mathbb N\)</span> (or another countable set);
or</p></li>
<li><p>Express <span class="math inline">\(X\)</span> as a countable
union of countable sets (usually the best); or</p></li>
<li><p>If <span class="math inline">\(X\)</span> is ‘in’ or ‘near’ <span
class="math inline">\(\mathbb R\)</span>, consider <span
class="math inline">\(\mathbb Q\)</span> (see Proof 2 above).</p></li>
</ol>
<h2 id="comparing-sizes-of-sets">Comparing sizes of sets</h2>
<p>Intuitively, we might think that:</p>
<ul>
<li><p>‘<span class="math inline">\(A\)</span> bijects with <span
class="math inline">\(B\)</span>’ means ‘<span
class="math inline">\(A\)</span> has the same size as <span
class="math inline">\(B\)</span>’.</p></li>
<li><p>‘<span class="math inline">\(A\)</span> injects into <span
class="math inline">\(B\)</span>’ means ‘<span
class="math inline">\(A\)</span> is at most as large as <span
class="math inline">\(B\)</span>’.</p></li>
<li><p>‘<span class="math inline">\(A\)</span> surjects onto <span
class="math inline">\(B\)</span>’ means ‘<span
class="math inline">\(A\)</span> is at least as large as <span
class="math inline">\(B\)</span>’.</p></li>
</ul>
<p>Of course, these analogies break down where <span
class="math inline">\(B\)</span> is zero, since there are no functions
from <span class="math inline">\(A\)</span> to <span
class="math inline">\(B\)</span> in this case. For these to make sense,
we require (for <span class="math inline">\(A,
B\neq\varnothing\)</span>) ‘<span class="math inline">\(A\)</span>
injects into <span class="math inline">\(B\)</span>’ to be true if and
only if ‘<span class="math inline">\(B\)</span> surjects onto <span
class="math inline">\(A\)</span>’, and vice versa.</p>
<ul>
<li><p>In the forward direction, we are given an injection <span
class="math inline">\(f\colon A \to B\)</span>. Pick some point <span
class="math inline">\(a_0\)</span> in <span
class="math inline">\(A\)</span>, and define a surjective function <span
class="math inline">\(g\colon B \to A\)</span> given by <span
class="math display">\[b \mapsto \begin{cases}
                  a   &amp; \text{if } \exists!\ a \in A, f(a) = b \\
                  a_0 &amp; \text{otherwise}
              \end{cases}\]</span> Since the mapping <span
class="math inline">\(f\)</span> is injective, the first case will
always provide a unique value of <span
class="math inline">\(a\)</span>.</p></li>
<li><p>Proving the converse, we are given a surjection <span
class="math inline">\(g\colon B \to A\)</span>. For each <span
class="math inline">\(a\)</span> in <span
class="math inline">\(A\)</span>, we have some <span
class="math inline">\(a&#39; \in B\)</span> with <span
class="math inline">\(g(a&#39;) = a\)</span> since <span
class="math inline">\(g\)</span> is a surjection. Let <span
class="math inline">\(f(a) = a&#39;\)</span> for each <span
class="math inline">\(a\in A\)</span>, and <span
class="math inline">\(f\)</span> is injective.</p></li>
</ul>
<h2 id="schröderbernstein-theorem">Schröder–Bernstein theorem</h2>
<p>Further, we must also have that if ‘<span
class="math inline">\(A\)</span> is at most as large as <span
class="math inline">\(B\)</span>’ and ‘<span
class="math inline">\(B\)</span> is at most as large as <span
class="math inline">\(A\)</span>’, then they must be the same size.
Otherwise this size intuition would not make sense.</p>
<h3>Theorem</h3>
<p>If <span class="math inline">\(f\colon A\to B\)</span> and <span
class="math inline">\(g\colon B\to A\)</span> are injections, then there
exists a bijection <span class="math inline">\(h\colon A\to
B\)</span>.</p>
<h3>Proof</h3>
<p>For <span class="math inline">\(a\in A\)</span>, we will write <span
class="math inline">\(g^{-1}(a)\)</span> to denote the unique <span
class="math inline">\(b \in B\)</span> such that <span
class="math inline">\(g(b) = a\)</span>, if such a <span
class="math inline">\(b\)</span> exists (and similarly for <span
class="math inline">\(f^{-1}(b)\)</span>). The ‘ancestor sequence’ of
<span class="math inline">\(a \in A\)</span> is <span
class="math display">\[g^{-1}(a), f^{-1}g^{-1}(a),
g^{-1}f^{-1}g^{-1}(a), \dots\]</span> which may terminate. So for any
ancestor, after undergoing the relevant function <span
class="math inline">\(f\)</span> or <span
class="math inline">\(g\)</span> repeatedly, we will end up at <span
class="math inline">\(a\)</span>. There are three possible
behaviours:</p>
<ul>
<li><p>Let <span class="math inline">\(A_0\)</span> be the subset of
<span class="math inline">\(A\)</span> such that the ancestor sequence
stops at even time, i.e. the last ancestor is in <span
class="math inline">\(A\)</span>;</p></li>
<li><p>Let <span class="math inline">\(A_1\)</span> be the subset of
<span class="math inline">\(A\)</span> such that the ancestor sequence
stops at odd time, i.e. the last ancestor is in <span
class="math inline">\(B\)</span>; and</p></li>
<li><p>Let <span class="math inline">\(A_\infty\)</span> be the subset
of <span class="math inline">\(A\)</span> such that the ancestor
sequence does not terminate.</p></li>
</ul>
<p>We specify 0 to be even, i.e. if <span class="math inline">\(a\in
A\)</span> has no ancestor <span
class="math inline">\(g^{-1}(a)\)</span>, then <span
class="math inline">\(a \in A_0\)</span>. We define similar subsets of
<span class="math inline">\(B\)</span>: <span
class="math inline">\(B_0\)</span>, <span
class="math inline">\(B_1\)</span>, <span
class="math inline">\(B_\infty\)</span>. Now:</p>
<ul>
<li><p><span class="math inline">\(f\colon A \to B\)</span> is a
bijection between <span class="math inline">\(A_0\)</span> and <span
class="math inline">\(B_1\)</span>. Clearly if some element <span
class="math inline">\(a\)</span> has an even number of ancestors, the
ancestors of <span class="math inline">\(f(a)\)</span> are exactly <span
class="math inline">\(a\)</span> and all of its ancestors, i.e. an odd
number. It is surjective because every element in <span
class="math inline">\(B_1\)</span> has an inverse <span
class="math inline">\(f^{-1}(b) \in A_0\)</span> by
construction.</p></li>
<li><p><span class="math inline">\(g\colon B \to A\)</span> is a
bijection between <span class="math inline">\(B_0\)</span> and <span
class="math inline">\(A_1\)</span> due to the same argument.</p></li>
<li><p><span class="math inline">\(f\)</span> (or <span
class="math inline">\(g\)</span>, both functions work for this proof)
bijects <span class="math inline">\(A_\infty\)</span> and <span
class="math inline">\(B_\infty\)</span>. It is surjective because for
every element <span class="math inline">\(b \in B\)</span>, it has some
ancestor <span class="math inline">\(f^{-1}(b) \in
A_\infty\)</span>.</p></li>
</ul>
<p>So the function <span class="math inline">\(h\colon A \to B\)</span>
is given by <span class="math display">\[h(a) = \begin{cases}
            f(a)      &amp; \text{if } a \in A_0      \\
            g^{-1}(a) &amp; \text{if } a \in A_1      \\
            f(a)      &amp; \text{if } a \in A_\infty
        \end{cases}\]</span> is a bijection. ◻</p>
<p>Let us consider an example of this theorem in action. Do <span
class="math inline">\([0, 1]\)</span> and <span
class="math inline">\([0,1]\cup[2,3]\)</span> biject? All we need is to
find an injection both ways.</p>
<ul>
<li><p>Let <span class="math inline">\(f\colon [0,1] \to [0,1] \cup
[2,3]\)</span> be the identity map <span class="math inline">\(f(x) =
x\)</span>.</p></li>
<li><p>Let <span class="math inline">\(g\colon [0,1] \cup [2,3] \to
[0,1]\)</span> be given by <span class="math inline">\(g(x) =
x/3\)</span>.</p></li>
</ul>
<p>It would also be nice to have that, for any sets <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span>, either <span
class="math inline">\(A\)</span> injects into <span
class="math inline">\(B\)</span> or <span
class="math inline">\(B\)</span> injects into <span
class="math inline">\(A\)</span>. Then we can create a total ordering,
rather than a partial ordering; we can compare any two sets. This is
proven to be true in the Part II course Logic and Set Theory.</p>
<h2 id="arbitrarily-large-sets">Arbitrarily large sets</h2>
<p>We have the sets <span class="math display">\[\mathbb N, \mathcal
P(\mathbb N), \mathcal P(\mathcal P(\mathbb N)), \dots, \mathcal
P^k(\mathbb N), \dots\]</span> Does every set <span
class="math inline">\(X\)</span> inject into one of those? It seems like
this might be true, but the set <span class="math display">\[X = \mathbb
N \cup \mathcal P(\mathbb N) \cup \mathcal P(\mathcal P(\mathbb N)) \cup
\dots\]</span> is a counterexample. Let us continue further with this
approach. <span class="math display">\[X&#39; = X \cup \mathcal P(X)
\cup \mathcal P(\mathcal P(X)) \cup \dots\]</span> <span
class="math display">\[X&#39;&#39; = X&#39; \cup \mathcal P(X&#39;) \cup
\mathcal P(\mathcal P(X&#39;)) \cup \dots\]</span> and so on. Now, does
every set inject into one of these sets? No, consider <span
class="math display">\[Y = X \cup X&#39; \cup X&#39;&#39; \cup
X&#39;&#39;&#39; \cup \dots\]</span> We can keep going forever. So we
can’t construct a set that all sets inject into.</p>
<h2 id="what-happens-next">What happens next?</h2>
<p>This is the end of the Numbers and Sets course. Here are a few of the
courses that feed from this course.</p>
<ul>
<li><p>Factorisation is taken further in the IB Groups, Rings and
Modules course.</p></li>
<li><p>Fermat’s Little Theorem, squares modulo <span
class="math inline">\(p\)</span> etc. are taken further in II Number
Theory.</p></li>
<li><p>The analysis chapter is extended by IA Analysis.</p></li>
<li><p>Countability and sizes of sets are taken further in the II Logic
and Set Theory course.</p></li>
</ul>
</main>

<footer>
  <p><a href="../../">Main Homepage</a></p>
</footer>

</body>
</html>
