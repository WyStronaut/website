<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>03_modular_arithmetic (MathJax Version)</title>
  <style>
    /* Styles will be inserted here */
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>

<a href="#main">Skip to main content</a>

<header>
  <h1>03_modular_arithmetic (MathJax Version)</h1>
</header>

<nav aria-label="Page Navigation">
  <ul>
    <li><a href="../">Back to Generated Index</a></li>
            <li><a href="../mathml/03_modular_arithmetic-mathml.html">Switch to MathML Version</a></li>
      </ul>
</nav>

<main id="main">
<h2 id="introduction">Introduction</h2>
<p>In modular arithmetic, we need to prove that things like addition and
multiplication are valid. In order to do this, we need to show that if
<span class="math inline">\(a \equiv a&#39; \mod n\)</span> and <span
class="math inline">\(b \equiv b&#39; \mod n\)</span> then, for example,
<span class="math inline">\(ab \equiv a&#39;b&#39;\)</span>. We can
prove these statements trivially by writing <span
class="math inline">\(a&#39; = a + kn\)</span> where <span
class="math inline">\(k\)</span> is some integer, then evaluating the
left and right hand sides in <span class="math inline">\(\mathbb
Z\)</span>.</p>
<p>Many rules of arithmetic are inherited from <span
class="math inline">\(\mathbb Z\)</span>; for example, addition is
commutative. This is easy to realise: to prove that <span
class="math inline">\(a + b = b + a\)</span> in <span
class="math inline">\(\mathbb Z_n\)</span> it is sufficient to prove the
statement is true in the whole of <span class="math inline">\(\mathbb
Z\)</span>.</p>
<p>As another example, we can transform the unique prime factorisation
lemma into <span class="math inline">\(\mathbb Z_p\)</span>. In <span
class="math inline">\(\mathbb Z_p\)</span> where <span
class="math inline">\(p\)</span> is prime, <span
class="math display">\[ab = 0 \implies (a = 0) \lor (b = 0)\]</span> In
general, <span class="math inline">\(\mathbb Z_p\)</span> where <span
class="math inline">\(p\)</span> is prime is a very well behaved and
convenient-to-use subset of <span class="math inline">\(\mathbb
Z\)</span>.</p>
<h2 id="inverses">Inverses</h2>
<p>For any <span class="math inline">\(a, b \in \mathbb Z_n\)</span>,
<span class="math inline">\(b\)</span> is an inverse of <span
class="math inline">\(a\)</span> if <span
class="math inline">\(ab=1\)</span>. Note that unlike in group theory,
it is not necessarily the case that all elements will have inverses. For
example, in <span class="math inline">\(\mathbb Z_{10}\)</span>, the
elements 3 and 7 are inverses, but 4 has no inverse. Note that:</p>
<ul>
<li><p>Invertible integers are cancellable. For example, <span
class="math inline">\(ab=ac \implies b=c\)</span> if <span
class="math inline">\(a\)</span> is invertible (by left-multiplying by
its inverse).</p></li>
<li><p>In general, you cannot simply cancel an integer multiple in the
realm of modular arithmetic. For example <span class="math inline">\(4
\cdot 5 = 2 \cdot 5\)</span> does not imply <span
class="math inline">\(4 = 2\)</span>.</p></li>
<li><p>Invertible numbers are also called ‘units’.</p></li>
</ul>
<h2 id="invertibility">Invertibility</h2>
<h3>Proposition</h3>
<p>Let <span class="math inline">\(n \geq 2\)</span>. Then every <span
class="math inline">\(a \not\equiv 0\ (n)\)</span> is invertible modulo
<span class="math inline">\(n\)</span> if and only if <span
class="math inline">\((a, n) = 1\)</span>. Note that the parenthesis
notation means the highest common factor of the parameters. In
particular, if <span class="math inline">\(n\)</span> is prime, then all
<span class="math inline">\(1 \leq a &lt; n\)</span> are invertible.</p>
<h3>Proof</h3>
<p>This first proof uses Euclid’s algorithm. If <span
class="math inline">\(a\)</span> and <span
class="math inline">\(n\)</span> satisfy <span class="math inline">\((a,
n) = 1\)</span> then <span class="math inline">\(ax + ny = 1\)</span>
for some <span class="math inline">\(x, y \in \mathbb Z\)</span>. So
<span class="math inline">\(ax = 1 - ny\)</span>, so <span
class="math inline">\(ax \equiv 1\ (n)\)</span>. So <span
class="math inline">\(x\)</span> is the inverse of <span
class="math inline">\(a\)</span>. ◻</p>
<h3>Proof</h3>
<p>This alternate proof only works for <span
class="math inline">\(n=p\)</span> where <span
class="math inline">\(p\)</span> is a prime; our whole proof lies
entirely within <span class="math inline">\(\mathbb Z_p\)</span>.
Consider <span class="math inline">\(0a, 1a, 2a, \cdots,
(p-1)a\)</span>. Take two numbers <span class="math inline">\(i,
j\)</span> between 0 and <span class="math inline">\(p-1\)</span>, then
consider the condition <span class="math inline">\(ia = ja\)</span>.
This implies that <span class="math inline">\((i - j)a = 0\)</span>, but
<span class="math inline">\(a \neq 0\)</span>, so <span
class="math inline">\(i=j\)</span>. So this list <span
class="math inline">\(0a, 1a, \cdots\)</span> contains all distinct
elements, all of which must be between 0 and <span
class="math inline">\(p-1\)</span>. Therefore, by the pigeonhole
principle, one of these elements must be equal to 1. Therefore there
exists an inverse for <span class="math inline">\(a\)</span>. ◻</p>
<h2 id="eulers-totient-function">Euler’s totient function</h2>
<h3>Definition</h3>
<p>Let <span class="math inline">\(\varphi(n)\)</span> be the amount of
natural numbers less than or equal to <span
class="math inline">\(n\)</span> that are coprime to <span
class="math inline">\(n\)</span>.</p>
<p>Here are some examples.</p>
<ul>
<li><p>If <span class="math inline">\(p\)</span> is prime, then <span
class="math inline">\(\varphi(p) = p - 1\)</span> since all naturals
less than <span class="math inline">\(p\)</span> are coprime to
it.</p></li>
<li><p><span class="math inline">\(\varphi(p^2) = p^2 - p\)</span>
because there are <span class="math inline">\(p\)</span> numbers in this
range who shares the common factor <span
class="math inline">\(p\)</span> with <span
class="math inline">\(p^2\)</span>, specifically the numbers <span
class="math inline">\(p, 2p, 3p, \cdots, (p-1)p, p^2\)</span>.</p></li>
<li><p>If <span class="math inline">\(a, b\)</span> are coprime, <span
class="math inline">\(\varphi(ab) = ab - a - b + 1\)</span>. There are
<span class="math inline">\(ab\)</span> numbers in total to pick from.
There are <span class="math inline">\(a\)</span> multiples of <span
class="math inline">\(b\)</span> and <span
class="math inline">\(b\)</span> multiples of <span
class="math inline">\(a\)</span>, and since we discounted <span
class="math inline">\(ab\)</span> itself twice we need to count it
again. Note that <span class="math inline">\(\varphi(ab) =
\varphi(a)\varphi(b)\)</span>.</p></li>
</ul>
<h2 id="fermats-little-theorem-and-fermateuler-theorem">Fermat’s little
theorem and Fermat–Euler theorem</h2>
<h3>Theorem</h3>
<p>Let <span class="math inline">\(p\)</span> be a prime. Then in <span
class="math inline">\(\mathbb Z_p\)</span>, <span
class="math inline">\(a \neq 0 \implies a^{p-1} = 1\)</span>.</p>
<p>This is actually a special case of the following theorem:</p>
<h3>Theorem</h3>
<p>Let <span class="math inline">\(n \geq 2\)</span>. Then in <span
class="math inline">\(\mathbb Z_n\)</span>, any unit <span
class="math inline">\(a\)</span> satisfies <span
class="math inline">\(a^{\varphi(n)} = 1\)</span>.</p>
<h3>Proof</h3>
<p>Let the set of units <span class="math inline">\(\mathbb Z_n \supset
X = \{ x_1, x_2, \cdots, x_{\varphi(n)} \}\)</span>. Consider
multiplying each unit by <span class="math inline">\(a\)</span>. We have
<span class="math inline">\(Y = \{ ax_1, ax_2, \cdots, ax_{\varphi(n)}
\}\)</span>. Since <span class="math inline">\(a\)</span> is invertible,
this set is comprised of distinct elements. Further, since they are all
products of units, they are all units. So <span
class="math inline">\(Y\)</span> is a list of <span
class="math inline">\(\varphi(n)\)</span> distinct units, so this list
must be equal to <span class="math inline">\(X\)</span>. Now, since the
lists are the same, the product of all their elements must be the same.
So <span class="math inline">\(\prod X = \prod Y = a^{\varphi(n)}\prod
X\)</span>. We can cancel the factor of <span
class="math inline">\(\prod X\)</span> because it is a product of
invertibles, leaving <span class="math inline">\(1 =
a^{\varphi(n)}\)</span> as required. ◻</p>
<p>If alternatively we wanted to prove this just for <span
class="math inline">\(p\)</span> prime, then we could replace <span
class="math inline">\(\varphi(n)\)</span> with <span
class="math inline">\(p-1\)</span>, and <span
class="math inline">\(\prod X\)</span> with <span
class="math inline">\((p-1)!\)</span>.</p>
<h2 id="square-roots-of-one">Square roots of one</h2>
<h3>Lemma</h3>
<p>Let <span class="math inline">\(p\)</span> be prime. Then in <span
class="math inline">\(\mathbb Z_p\)</span>, <span
class="math inline">\(x^2 = 1\)</span> has solutions <span
class="math inline">\(1\)</span> and <span
class="math inline">\(-1\)</span> only.</p>
<h3>Note</h3>
<p>In <span class="math inline">\(\mathbb Z_8\)</span>, for example, we
have <span class="math inline">\(1^2 = 3^2 = 5^2 = 7^2 = 1\)</span>, so
obviously this does not hold in the general case.</p>
<h3>Proof</h3>
<p><span class="math inline">\(x^2 = 1\)</span> implies that <span
class="math inline">\((x-1)(x+1) = 0\)</span>. Because of the <span
class="math inline">\(p\mid ab\implies (p\mid a) \lor (p\mid b)\)</span>
lemma, we know that <span class="math inline">\((x-1) = 0\)</span> or
<span class="math inline">\((x+1) = 0\)</span>, so <span
class="math inline">\(-1\)</span> and <span
class="math inline">\(1\)</span> are the only solutions. ◻</p>
<h2 id="square-roots-of-negative-one">Square roots of negative one</h2>
<h3>Theorem</h3>
<p>Let <span class="math inline">\(p\)</span> be prime. Then <span
class="math inline">\((p-1)!
    \equiv -1\ (p)\)</span>.</p>
<h3>Proof</h3>
<p>Since this is obviously true for <span
class="math inline">\(p=2\)</span>, we will suppose that <span
class="math inline">\(p&gt;2\)</span>. In <span
class="math inline">\(\mathbb Z_p\)</span>, let us consider the list
<span class="math inline">\(1, 2, 3 \cdots (p-1)\)</span>. We can pair
each <span class="math inline">\(a\)</span> with its inverse <span
class="math inline">\(a^{-1}\)</span> for all <span
class="math inline">\(a \neq a^{-1}\)</span>. Note that <span
class="math inline">\(a = a^{-1} \iff a^2 = 1\)</span> so in this case
<span class="math inline">\(a=1\)</span> or <span
class="math inline">\(a=-1\)</span>. So let us now multiply each element
together, to get <span class="math display">\[(p-1)!
        = (aa^{-1}) (bb^{-1}) \cdots 1 \cdot -1 = (1) \cdot (1) \cdots 1
\cdot -1 = -1\]</span> ◻</p>
<h3>Proposition</h3>
<p>Let <span class="math inline">\(p&gt;2\)</span> be prime. Then <span
class="math inline">\(-1\)</span> is a square number modulo <span
class="math inline">\(p\)</span> if and only if <span
class="math inline">\(p \equiv 1\ (4)\)</span>.</p>
<h3>Proof</h3>
<p>If <span class="math inline">\(p&gt;2\)</span> then <span
class="math inline">\(p\)</span> is odd. There are therefore two cases,
either <span class="math inline">\(p \equiv 1\)</span> or <span
class="math inline">\(p \equiv 3\)</span> modulo 4. Each case is proven
individually.</p>
<ul>
<li><p>(<span class="math inline">\(p = 4k + 3\)</span>) Suppose that
<span class="math inline">\(x^2 = -1\)</span> in <span
class="math inline">\(\mathbb Z_p\)</span>. The only thing we know about
powers in modular arithmetic is Fermat’s Little Theorem, so we will have
to use this. So, <span class="math inline">\(x^{p-1} = x^{4k+2} =
1\)</span>. Therefore, <span class="math inline">\((x^2)^{2k+1} =
1\)</span>. But we know that <span
class="math inline">\(x^2=-1\)</span>, and we raise this <span
class="math inline">\(-1\)</span> to an odd power, which is <span
class="math inline">\(-1\)</span>. So this is a contradiction.</p></li>
<li><p>(<span class="math inline">\(p = 4k + 1\)</span>) By Wilson’s
Theorem, we know that <span class="math inline">\((4k)!
              = -1\)</span>. We intend to show that this is a square
number in the world of <span class="math inline">\(\mathbb Z_p\)</span>.
We will compare the termwise expansion of <span
class="math inline">\((4k)!\)</span> and <span
class="math inline">\([(2k)!]^2\)</span> on consecutive lines. <span
class="math display">\[\begin{alignat*}
{9}
                  (4k)!
                            &amp; = 1 &amp;  &amp; \cdot 2 &amp;  &amp;
\cdot 3 &amp;  &amp; \cdots (2k) &amp;  &amp; \cdot (2k+1) &amp;  &amp;
\cdot (2k+2)  &amp;  &amp; \cdots (4k-1)  &amp;  &amp; \cdot
(4k)                   \\
                  [(2k)!]^2 &amp; = 1 &amp;  &amp; \cdot 2 &amp;  &amp;
\cdot 3 &amp;  &amp; \cdots (2k) &amp;  &amp; \cdot 1      &amp;  &amp;
\cdot 2       &amp;  &amp; \cdots (2k-1)  &amp;  &amp; \cdot
(2k)                   \\
                  \intertext{By writing each term as an equivalent
negative:}
                            &amp; = 1 &amp;  &amp; \cdot 2 &amp;  &amp;
\cdot 3 &amp;  &amp; \cdots (2k) &amp;  &amp; \cdot (-4k)  &amp;  &amp;
\cdot (-4k+1) &amp;  &amp; \cdots (-2k-2) &amp;  &amp; \cdot
(-2k-1)                \\
                  \intertext{Extracting out the negatives:}
                            &amp; = 1 &amp;  &amp; \cdot 2 &amp;  &amp;
\cdot 3 &amp;  &amp; \cdots (2k) &amp;  &amp; \cdot (4k)   &amp;  &amp;
\cdot (4k-1)  &amp;  &amp; \cdots (2k+2)  &amp;  &amp; \cdot (2k+1)
\cdot (-1)^{2k}
\end{alignat*}\]</span> which is equal to the first line by rearranging.
So <span class="math inline">\([(2k)!]^2 = (4k)!
              = -1\)</span>. So <span class="math inline">\(-1\)</span>
is a square number modulo <span
class="math inline">\(p\)</span>.</p></li>
</ul>
<p> ◻</p>
<h2 id="solving-congruence-equations">Solving congruence equations</h2>
<p>Let us try to solve the equation <span class="math inline">\(7x
\equiv 4\ (30)\)</span>. We take a two-phase approach: first, we will
find a single solution, and then we will find all of the other
solutions.</p>
<p>Since 7 and 30 are coprime, we can use Euclid’s algorithm to find a
way of expressing 1 in terms of 7 and 30, in particular <span
class="math inline">\(13 \cdot 7 - 3\cdot 30 = 1\)</span>. This allows
us to solve <span class="math inline">\(7y \equiv 1\ (30)\)</span>, by
setting <span class="math inline">\(y=13\)</span>. Then, of course, we
can multiply both sides by 4: <span class="math inline">\(7 y\cdot 4
\equiv 4\ (30)\)</span>, so <span class="math inline">\(x = y \cdot 4 =
13 \cdot 4 = 22\)</span>.</p>
<p>We can now find other solutions (apart from trivially adding <span
class="math inline">\(30k\)</span>). Suppose that there exists some
other solution <span class="math inline">\(x&#39;\)</span>, i.e. <span
class="math inline">\(7x&#39; \equiv 4\ (30)\)</span>. Then <span
class="math inline">\(7x \equiv 7x&#39;\ (30)\)</span>. As 7 is
invertible modulo 30, we can simply multiply by the inverse of 7 to give
<span class="math inline">\(x \equiv x&#39;\ (30)\)</span>. So <span
class="math inline">\(x\)</span> is unique modulo 30. Alternatively, we
could solve the equation without any of this working out by noticing
that 7 is invertible! However, this is not very likely to happen in the
general case, since it requires that the coefficient of <span
class="math inline">\(x\)</span> is coprime to the modulus.</p>
<p>Now, let’s try a different equation, <span class="math inline">\(10x
= 12\ (34)\)</span>. Since 10 is not invertible, we can’t do quite the
same thing as above. We can’t also just divide the whole thing by 2,
there isn’t a rule for that in general. We can, however, move into <span
class="math inline">\(\mathbb Z\)</span> and manipulate the expression
there. <span class="math inline">\(10x = 12 + 34y\)</span> for some
<span class="math inline">\(y \in \mathbb Z\)</span>, so we can divide
the equation by 2 to get <span class="math inline">\(5x = 6 +
17y\)</span>, so <span class="math inline">\(5x = 6\ (17)\)</span> and
we can solve from there.</p>
<h2 id="chinese-remainder-theorem">Chinese remainder theorem</h2>
<p>Is there a solution for the simultaneous congruences <span
class="math display">\[x \equiv 6\ (17);\quad x \equiv 2\ (19)\]</span>
17 and 19 are coprime, so congruence mod 17 and congruence mod 19 are
independent of each other. How about <span class="math display">\[x
\equiv 6\ (34);\quad x \equiv 11\ (36)\]</span> In this instance, there
is obviously no solution; should <span class="math inline">\(x\)</span>
be even or odd? We can see that, the smallest amount we can adjust <span
class="math inline">\(x\)</span> by in one equation while retaining
congruence in the other equation is <span class="math inline">\(\HCF(34,
36)\)</span>, which is 2.</p>
<h3>Theorem</h3>
<p>Let <span class="math inline">\(u, v\)</span> be coprime. Then for
any <span class="math inline">\(a, b\)</span>, there exists a value
<span class="math inline">\(x\)</span> such that <span
class="math display">\[x \equiv a\ (u);\quad x \equiv b\ (v)\]</span>
and that this value is unique modulo <span
class="math inline">\(uv\)</span>.</p>
<h3>Proof</h3>
<p>We first prove existence of such an <span
class="math inline">\(x\)</span>. By Euclid’s Algorithm, we have <span
class="math inline">\(su + tv = 1\)</span> for some integers <span
class="math inline">\(s, t\)</span>. Note that therefore: <span
class="math display">\[su \equiv 0\ (u);\quad tv \equiv 0\ (v);\quad su
\equiv 1\ (v);\quad tv \equiv 1\ (u);\]</span> Therefore we can make a
linear combination of <span class="math inline">\(su\)</span> and <span
class="math inline">\(tv\)</span> that is the required size in each
congruence, specifically <span class="math display">\[x = (su)b +
(tv)a\]</span> Now we prove that this value <span
class="math inline">\(x\)</span> is unique modulo <span
class="math inline">\(uv\)</span>. Suppose there was some other solution
<span class="math inline">\(x&#39;\)</span>. Also, <span
class="math inline">\(x&#39; \equiv x\ (u)\)</span> and <span
class="math inline">\(x&#39; \equiv x\ (v)\)</span>. So we have <span
class="math inline">\(u\mid (x&#39; - x)\)</span> and <span
class="math inline">\(v\mid (x&#39; - x)\)</span> but as <span
class="math inline">\(u\)</span> and <span
class="math inline">\(b\)</span> are coprime we have <span
class="math inline">\(uv\mid (x&#39; - x)\)</span>. So <span
class="math inline">\(x\)</span> is unique modulo <span
class="math inline">\(uv\)</span>. ◻</p>
<h2 id="rsa-encryption">RSA encryption</h2>
<p>A practical use of number theory is RSA encryption, which is an
asymmetric encryption protocol that allows encryption by using a public
and private key pair. We will begin by first choosing two large distinct
primes <span class="math inline">\(p\)</span> and <span
class="math inline">\(q\)</span>. By large, we mean primes that are
hundreds of digits long; in practice, these primes are between around
512 bits and 2048 bits long when represented in binary. Let <span
class="math inline">\(n=pq\)</span>, and pick a ‘coding exponent’ <span
class="math inline">\(e\)</span>. Our message that we want to send must
be an element of <span class="math inline">\(\mathbb Z_n\)</span>, so if
it is not representable in this form we must break it apart into several
smaller messages, or perhaps use RSA to share some kind of small
symmetric key for another encryption algorithm. Let this message be
<span class="math inline">\(x\)</span>, so <span class="math inline">\(x
&lt; n\)</span>.</p>
<p>To encode <span class="math inline">\(x\)</span>, we raise it to the
power <span class="math inline">\(e\)</span> in <span
class="math inline">\(\mathbb Z_n\)</span>. To efficiently compute large
powers of <span class="math inline">\(x\)</span>, we can use a repeated
squaring technique. For example, we can find <span
class="math inline">\(x, x^2, x^4, x^8, x^{16}\)</span> through repeated
squaring, and then for example we can calculate <span
class="math inline">\(x^{19} = x^{16} x^{2} x^{1}\)</span>.</p>
<p>To decode <span class="math inline">\(x^e\)</span>, we ideally want
some number <span class="math inline">\(d\)</span> such that <span
class="math inline">\((x^e)^d = x\)</span>. By the Fermat–Euler Theorem,
we have <span class="math inline">\(x^{\varphi(n)} = 1\)</span>, so
clearly <span class="math inline">\(x^{k\varphi(n) + 1} = x\)</span>. In
other words, we want <span class="math inline">\(ed \equiv 1 \mod
\varphi(n)\)</span>. By running Euclid’s algorithm on <span
class="math inline">\(e\)</span> and <span
class="math inline">\(\varphi(n)\)</span>, we can find such a <span
class="math inline">\(d\)</span>. Note that this requires <span
class="math inline">\(e\)</span> and <span
class="math inline">\(\varphi(n)\)</span> to be coprime; in practice we
would choose <span class="math inline">\(e\)</span> after we have chosen
<span class="math inline">\(n\)</span> such that this is the case.</p>
<p>Now, we can see that to encode a message, all you need is <span
class="math inline">\(n\)</span> and <span
class="math inline">\(e\)</span>. However, to decode, you need to also
know <span class="math inline">\(d\)</span>, which means you need to
know <span class="math inline">\(\varphi(n) = \varphi(pq) = pq - p - q +
1\)</span> which requires that you know the original <span
class="math inline">\(p\)</span> and <span
class="math inline">\(q\)</span>. If we pick sufficiently large <span
class="math inline">\(p\)</span> and <span
class="math inline">\(q\)</span>, our <span
class="math inline">\(n\)</span> will be so big as to be almost
impossible to factorise in any decent length of time. So we can publish
<span class="math inline">\(n\)</span> and <span
class="math inline">\(e\)</span> as our public key, and anyone may use
these numbers to encrypt a message that then only we can decode.</p>
</main>

<footer>
  <p><a href="../../">Main Homepage</a></p>
</footer>

</body>
</html>
